# 1장 오브젝트와 의존관계
> 스프링은 자바를 기반으로 한 기술이다. 스프링이 자바에서 가장 중요하게 가치를 두는 것은 바로 객체지향 프로그래밍이 가능한 언어라는 점이다.

> 스프링을 이해하기 위새허는 오브젝트에 깊은 관심을 가져야한다.

1장에서는 오브젝트의 설계와 구현, 동작원리에 대해 알아보자.

## 1.1 초난감 DAO

- DAO
  - 'DataAccess Object' 의 약자로 DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트를 의미한다.

### 1.1.1 User

- 자바빈: 아래의 두 가지 관례에 따라 만들어진 오브젝트를 의미한다.
  - 디폴트 생성자: 파라미터가 없는 디폴트 생성자를 가지고 있어야한다.
  - 프로퍼티: 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라고 말하며 수정자 메소드인 `setter`와 접근자 메소드인 `getter`를 이용해 조회, 수정할 수 있다.

### 1.1.2 UserDao

- JDBC 연결 방법
  - DB 연결을 위한 `Connection` 호출
  - SQL 을 담은 `Statement` 생성
  - `Statement` 실행
  - 결과 값을 `ResultSet` 으로 받아 오브젝트(User)에 옮겨준다.
  - 생성했던 `Connection`, `Statement`, `ResultSet` 를 종료시킨다.
  - 예외 발생 시 메소드 밖으로 던진다.


### 1.1.3 main()을 이용한 DAO 테스트 코드

main 으로 작성된 테스트 코드를 실행했을 때 오류가 발생하지는 않지만 1.1.2 까지 작성된 코드는 잘못된 코드이다.


## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

소프트웨어 개발은 애플리케이션의 사용이 중지될 때까지 끝나지 않는다.

오브젝트에 대한 설계와 이를 구현한 코드는 언제든지 바뀔 수 있다.

✔ 객체를 설계할 때 가장 염두할 사항은 **미래의 변화에 어떻게 대비할 것인가**이다.  
변경이 발생했을 때 작업을 최소화하고 해당 작업으로 인한 다른 부분에 문제 발생이 없게 할 방법
<br><br>

**분리와 확장을 고려한 설계**
- 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
- 하지만 작업이 한곳에 집중되지 않는 경우가 많다.
  

- DB 접속용 암호가 변경되었다면?
  - 현재의 코드에서는 파일에 들어있는 connection 부분을 모두 찾아 비밀번호를 수정해야한다.
<br><br>

>- 관심사의 분리
>  - 프로그래밍의 기초 개념 중 하나
>  - 객체지향에 적용하면 관심이 같은 것끼리는 하나의 객체 안으로 모으고, 관심이 다르면 서로 영향을 주지 않도록 분리하는 방법이다.


### 1.2.2 커넥션 만들기의 추출

- UserDao 의 관심사항
  - DB와의 연결을 위한 커넥션을 어떻게 가져올지에 대한 방법
  - 파라미터로 넘어온 사용자 정보를 Statement 에 바인딩 시키고 DB를 통해 실행시키는 방법
  - 작업이 끝나고 사용한 리소스를 어떻게 닫을지에 대한 방법

  => 가장 문제가 되는 코드는 Connection 을 호출하는 부분으로 get() 메서드와 add() 메서드에 중복되어 사용되고 있다.


<br>
1. 중복 코드의 메소드 추출

커넥션을 가져오는 중복된 코드를 하나의 메소드로 만들어서 커넥션을 리턴한다.
<br>이 과정을 통해 커넥션 부분이 2000개가 되어도 getConnection() 의 내용만 수정하면 되기 때문에 편리해진다.


> - 리팩토링: 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해 재구성하는 작업을 말한다.
>  - 코드 내부의 설계가 개선되어 코드의 이해가 쉬워지고, 변화에 효율적으로 대응할 수 있다.
>  
> 
>- 메소드 추출: 리팩토링 기법 중 하나로 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것을 의미한다.

### 1.2.3 DB 커넥션 만들기의 독립

**UserDao의 코드 제공 없이 사용자별 Connection을 생성하고 싶다면?**
<br>=>상속을 통한 확장<br>
&nbsp;&nbsp;&nbsp;&nbsp; : getConnection() 메서드를 추상 메소드로 변경해 사용자별로 상속받아 직접 구현해 넘기게 한다.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이러한 패턴을 템플릿 메소드 패턴이라 한다.

위의 방법으로 기능을 확장할 수 있지만 상속을 사용했기 때문에 다중상속으로 인한 문제가 발생할 수 있고 상속을 통해 상하위 클래스의 관계가 생각보다 밀접해져 다른 관심사에 대한 결합이 허용된다.

<br>

>
>- 디자인 패턴
>  - 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다.
>  - 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도이다. 패턴을 적용할 상황, 해결해야 할 문제, 솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지 기억해야한다.
>
>
>- 템플릿 메소드 패턴
>  - 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용된다.
>  - 변하지 않는 기능은 슈퍼클래스에 만들고 자주 변경되거나 확장 되는 기능은 추상 메소드나 오버라이드 가능한 메소드로 정의해 서브 클래스에서 만들 수 있게 만든다.
>    - 공통된 역할을 수행하는 메서드인 템플릿 메서드(Template Method)
>    - 반드시 구현해야 하는 추상 메서드(Primitive Method)
>    - 그대로 사용해도 되고 오버라이딩해서 사용해도 되는 훅 메서드(Hook Method)
>  - 하위 클래스가 전체 로직을 변경하지 않으면서 부분적인 수정이 가능해진다.
>
>
>- 팩토리 메소드 패턴
>  - 템플릿과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴
>  - 슈퍼클래스에서 서브클래스의 메소드를 호출해 필요한 타입의 오브젝트를 가져와 사용하는데 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴해 서브클래스에서 어떤 클래스의 오브젝트를 만들어 리턴하는지 슈퍼클래스에서는 알지 못한다.
>  - 따라서 결합도가 낮아진다.


## 1.3 DAO의 확장

오브젝트가 모두 동일한 방식으로 변하지 않고 관심사에 따라 분리한 오브젝트들은 각자 다른 변화의 이유, 시기, 주기 등의 특징을 가진다.

### 1.3.1 클래스의 분리

상속은 여러가지 제약사항이 생길 수 있다. 따라서 상속이 아닌 완전히 독립된 메소드로 분리하는것이 미래를 대비하기에 더 효율적이다.

1. 새로운 클래스를 생성하고 새로운 클래스에 DB 생성 기능을 추가한다. 
2. UserDao에서는 new 키워드를 이용해 새로운 클래스의 오젝트를 만들고 add()와 get()에 사용한다.
   - 이때 각 메소드에서 새로운 오브젝트를 생성하기보다 변수에 저장해 메서드에서 활용하게 만든다.

독립된 클래스로 분리했지만 다시 클래스의 내용이 바뀌면 UserDao의 코드가 수정되어야하고, UserDao에서 제공하는 클래스에 대해 구체적으로 알고있어야 한다는 문제가 발생한다.


### 1.3.2 인터페이스의 도입

인터페이스를 만들면 클래스를 분리하면서도 위의 문제를 해결할 수 있다.

인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이기 때문에 서브클래스에서는 해당 기능을 구현하고, 슈퍼클래스에서는 기능에만 관심을 가지게 된다.

1. 인터페이스를 정의하고 메소드를 작성한다.
2. 서브 클래스에서는 implements 로 인터페이스를 받고, 구현한다.
3. 메인에서는 인터페이스를 통해 오브젝트에 접근하고 인터페이스의 정의된 메소드를 사용해 Connection을 가져온다.

인터페이스를 사용해 커넥션을 제공하는 클래스에 대한 구체적인 정보는 제거했지만 초기에 어떤 오브젝트를 사용할지에 대한 결정은 생성자 코드에 남아있게 된다.


### 1.3.3 관계설정 책임의 분리

관심사항에 대해 다시 생각해보자.

- UserDao에는 어떤 ConnectionMaker 클래스를 사용할지 결정하는 코드가 존재하는데 이 코드는 DB의 정보를 가져오거나 커넥션을 어떻게 가져올지에 대한 관심사가 아닌 어떤 구현 클래스를 이용할지에 대한 관심사만 가지고 있다.
- 관심사 분리를 위해 클라이언트에서 UserDao를 사용하기 전에 어떤 구현 클래스를 사용할지 결정하게 한다.
  - UserDao의 모든 코드가 Connection 인터페이스 외에는 어떤 클래스와도 관계를 가지지 않게된다.


### 1.3.4 원칙과 패턴

- 개방 폐쇄 원칙(OCP, Open-Closed Principle))
  - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
  - UserDao에는 영향을 주지 않으면서 새로운 DB 연결에 대한 확장은 열려있다.
- 높은 응집도와 낮은 결합도
  - DB 연결 방식에 변경이 일어나도 다른 부분을 확인할 필요 없이 변경한 ConnectionMaker 구현 클래스만 테스트하면 된다.
  - DB 연결 방식에 변경이 일어났을 때 UserDao의 변경 없이 클라이언트의 클래스만 변경하면 된다.
- 전략 패턴
  - 필요에 따라 클라이언트에서 DB 연결 클래스를 변경해서 사용할 수 있다.


> - 객체지향 설계 원칙(SOLID): 객체지향의 특징을 잘 살릴 수 있는 설계의 특징
>   - SRP: 단일 책임 원칙
>   - OCP: 개방 폐쇄 원칙
>   - LSP: 리스코프 치환 원칙
>   - ISP: 인터페이스 분리 원칙
>   - DIP: 의존관계 역전 원칙 
 

>  - 응집도
>    - 변화가 일어났을 때 그 변화가 모듈에 영향을 끼치는 정도를 말한다.
>  - 결합도
>    - 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도를 말한다.

> - 전략 패턴
>   - 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리하고, 이를 구현한 구체적인 알고리즘은 필요에 따라 바꿔 사용할 수 있게 하는 디자인 패턴이다.

